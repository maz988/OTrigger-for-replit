import React, { useState, useEffect } from 'react';
import { Link } from 'wouter';
import { useQuery, useMutation } from '@tanstack/react-query';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardHeader, 
  CardTitle, 
  CardFooter 
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '@/components/ui/alert-dialog';
import { Table, TableBody, TableCaption, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import RichTextEditor from '@/components/RichTextEditor';
import { apiRequest, queryClient } from '@/lib/queryClient';
import { 
  ArrowLeft,
  Plus,
  Filter,
  Pencil,
  Trash2,
  Eye,
  Search,
  ArrowUpDown,
  SortAsc,
  SortDesc,
  UploadCloud,
  Tag,
  Image as ImageIcon,
  Link as LinkIcon,
  Save,
  FileText,
  CheckCircle2,
  XCircle,
  Loader2
} from 'lucide-react';

// Define types
interface BlogPost {
  id: number;
  title: string;
  slug: string;
  content: string;
  keyword: string;
  category: string;
  publishedAt: string;
  updatedAt: string | null;
  autoGenerated: boolean;
  tags: string[];
  imageUrls: string[];
}

interface Keyword {
  id: number;
  keyword: string;
  used: boolean;
  category?: string;
}

const BlogManagement: React.FC = () => {
  // State variables
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [isViewDialogOpen, setIsViewDialogOpen] = useState(false);
  const [isKeywordDialogOpen, setIsKeywordDialogOpen] = useState(false);
  const [isAutoScheduleDialogOpen, setIsAutoScheduleDialogOpen] = useState(false);
  const [selectedPostId, setSelectedPostId] = useState<number | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterType, setFilterType] = useState<'all' | 'auto' | 'manual'>('all');
  const [sortField, setSortField] = useState<'date' | 'title' | 'keyword'>('date');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  const [newKeyword, setNewKeyword] = useState('');
  const [newKeywordCategory, setNewKeywordCategory] = useState('relationships');
  
  // Auto-scheduling state
  const [schedulingEnabled, setSchedulingEnabled] = useState(false);
  const [scheduleFrequency, setScheduleFrequency] = useState<'daily' | 'twice-daily' | 'every-other-day' | 'weekly'>('daily');
  const [scheduleTime, setScheduleTime] = useState('10:00');
  const [lastGenerated, setLastGenerated] = useState<string | null>(null);
  const [lastGeneratedKeyword, setLastGeneratedKeyword] = useState<string | null>(null);
  const [lastError, setLastError] = useState<string | null>(null);
  
  // Form state for post editing/creation
  const [formData, setFormData] = useState<Partial<BlogPost>>({
    title: '',
    slug: '',
    content: '',
    keyword: '',
    category: 'Relationships',
    tags: [],
    imageUrls: [],
    autoGenerated: false
  });
  
  // Tag input state
  const [tagInput, setTagInput] = useState('');
  
  const { toast } = useToast();

  // Get the admin token from localStorage
  const token = localStorage.getItem('adminToken');
  
  // Fetch blog posts
  const { data: postsResponse, isLoading: postsLoading } = useQuery({
    queryKey: ['/api/admin/blog/posts'],
    queryFn: async () => {
      if (!token) {
        throw new Error('No authentication token found');
      }
      
      const response = await fetch('/api/admin/blog/posts', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      return await response.json();
    }
  });
  
  // Fetch keywords
  const { data: keywordsResponse, isLoading: keywordsLoading, refetch: refetchKeywords } = useQuery({
    queryKey: ['/api/admin/keywords'],
    queryFn: async () => {
      if (!token) {
        throw new Error('No authentication token found');
      }
      
      const response = await fetch('/api/admin/keywords', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      return await response.json();
    }
  });
  
  // Blog posts data
  const blogPosts: BlogPost[] = postsResponse?.data || [];
  
  // Convert keyword strings to Keyword objects for compatibility
  const keywords: Keyword[] = keywordsResponse?.data 
    ? keywordsResponse.data.map((keyword: string, index: number) => ({
        id: index,
        keyword: keyword,
        used: false,
        category: 'general'
      }))
    : [];
  
  // Filter and sort blog posts
  const filteredPosts = blogPosts
    .filter(post => {
      // Filter by type (auto/manual)
      if (filterType === 'auto' && !post.autoGenerated) return false;
      if (filterType === 'manual' && post.autoGenerated) return false;
      
      // Filter by search term
      if (searchTerm && !post.title.toLowerCase().includes(searchTerm.toLowerCase()) &&
          !post.keyword.toLowerCase().includes(searchTerm.toLowerCase())) {
        return false;
      }
      
      return true;
    })
    .sort((a, b) => {
      // Sort by selected field
      if (sortField === 'date') {
        return sortDirection === 'desc' 
          ? new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()
          : new Date(a.publishedAt).getTime() - new Date(b.publishedAt).getTime();
      } else if (sortField === 'title') {
        return sortDirection === 'desc'
          ? b.title.localeCompare(a.title)
          : a.title.localeCompare(b.title);
      } else if (sortField === 'keyword') {
        return sortDirection === 'desc'
          ? b.keyword.localeCompare(a.keyword)
          : a.keyword.localeCompare(b.keyword);
      }
      return 0;
    });
  
  // Add new keyword mutation
  const addKeywordMutation = useMutation({
    mutationFn: async (newKeywordData: { keyword: string, category: string }) => {
      if (!token) {
        throw new Error('No authentication token found');
      }
      
      const response = await fetch('/api/admin/keywords', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ keyword: newKeywordData.keyword }) // The API only accepts a keyword string
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      return await response.json();
    },
    onSuccess: () => {
      toast({
        title: 'Keyword Added',
        description: 'The new keyword has been added successfully.',
        variant: 'default',
      });
      setNewKeyword('');
      refetchKeywords();
    },
    onError: (error: Error) => {
      toast({
        title: 'Error Adding Keyword',
        description: error.message,
        variant: 'destructive',
      });
    }
  });
  
  // Create post mutation
  const createPostMutation = useMutation({
    mutationFn: async (newPost: Partial<BlogPost>) => {
      if (!token) {
        throw new Error('No authentication token found');
      }
      
      const response = await fetch('/api/admin/blog/posts', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(newPost)
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      return await response.json();
    },
    onSuccess: () => {
      toast({
        title: 'Post Created',
        description: 'The blog post has been created successfully.',
        variant: 'default',
      });
      setIsCreateDialogOpen(false);
      resetFormData();
      queryClient.invalidateQueries({ queryKey: ['/api/admin/blog/posts'] });
    },
    onError: (error: Error) => {
      toast({
        title: 'Error Creating Post',
        description: error.message,
        variant: 'destructive',
      });
    }
  });
  
  // Update post mutation
  const updatePostMutation = useMutation({
    mutationFn: async (updatedPost: Partial<BlogPost>) => {
      if (!token || !selectedPostId) {
        throw new Error('No authentication token or post ID found');
      }
      
      const response = await fetch(`/api/admin/blog/posts/${selectedPostId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updatedPost)
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      return await response.json();
    },
    onSuccess: () => {
      toast({
        title: 'Post Updated',
        description: 'The blog post has been updated successfully.',
        variant: 'default',
      });
      setIsEditDialogOpen(false);
      queryClient.invalidateQueries({ queryKey: ['/api/admin/blog/posts'] });
    },
    onError: (error: Error) => {
      toast({
        title: 'Error Updating Post',
        description: error.message,
        variant: 'destructive',
      });
    }
  });
  
  // Delete post mutation
  const deletePostMutation = useMutation({
    mutationFn: async (postId: number) => {
      if (!token) {
        throw new Error('No authentication token found');
      }
      
      const response = await fetch(`/api/admin/blog/posts/${postId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      return await response.json();
    },
    onSuccess: () => {
      toast({
        title: 'Post Deleted',
        description: 'The blog post has been deleted successfully.',
        variant: 'default',
      });
      setIsDeleteDialogOpen(false);
      queryClient.invalidateQueries({ queryKey: ['/api/admin/blog/posts'] });
    },
    onError: (error: Error) => {
      toast({
        title: 'Error Deleting Post',
        description: error.message,
        variant: 'destructive',
      });
    }
  });
  
  // Generate post with AI mutation
  const generatePostMutation = useMutation({
    mutationFn: async (keywordData: { keyword: string }) => {
      if (!token) {
        throw new Error('No authentication token found');
      }
      
      try {
        const response = await fetch('/api/admin/blog/generate', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(keywordData)
        });
        
        // Even if response is not OK, read the body and attempt to use it
        const data = await response.json();
        
        // Check if there's usable data even in an error response
        if (data && data.data) {
          return data;
        }
        
        // If response wasn't OK and there's no usable data, create fallback
        if (!response.ok) {
          // Instead of throwing, return a fallback post structure
          const keyword = keywordData.keyword;
          return {
            success: true,
            data: {
              title: `${keyword}: How to Understand and Connect Better`,
              slug: `${keyword.toLowerCase().replace(/[^a-z0-9]+/g, '-')}-how-to-understand-and-connect-better`,
              content: `<h2>Understanding ${keyword}</h2><p>Relationships can be complex, especially when it comes to ${keyword}. When you experience this in your relationship, it's important to understand the underlying male psychology at play.</p><p>Men often respond to emotional triggers in ways that confuse women, but there's usually a pattern to these behaviors that relates to their need for appreciation and respect.</p><h2>The Connection Between ${keyword} and His Inner Hero</h2><p>Research shows that men have a natural instinct to protect and provide. When you understand how to connect with this instinct through the right words and actions, you'll see tremendous changes in how he responds to you.</p><p>Try these techniques to create a stronger bond and watch how quickly things improve in your relationship.</p>`,
              imageUrls: [],
              tags: ["relationships", keyword.toLowerCase(), "communication", "psychology"],
              autoGenerated: true,
              keyword: keyword
            },
            note: "Using fallback content due to AI generation limitations"
          };
        }
        
        return data;
      } catch (error) {
        // Handle any network or parsing errors with a fallback
        console.error("Error in generatePostMutation:", error);
        const keyword = keywordData.keyword;
        
        return {
          success: true,
          data: {
            title: `${keyword}: Relationship Insights`,
            slug: `${keyword.toLowerCase().replace(/[^a-z0-9]+/g, '-')}-relationship-insights`,
            content: `<h2>Understanding ${keyword}</h2><p>Every relationship has its challenges, and ${keyword} is an important aspect to consider. This article will help you navigate this topic effectively.</p><p>Let's explore some key insights about ${keyword} and how it affects your relationship dynamics.</p>`,
            imageUrls: [],
            tags: ["relationships", "advice", keyword.toLowerCase()],
            autoGenerated: true,
            keyword: keyword
          },
          note: "Using emergency fallback content due to technical difficulties"
        };
      }
    },
    onSuccess: (data) => {
      let toastMessage = 'The AI has generated a new blog post draft.';
      let toastVariant: 'default' | 'destructive' = 'default';
      
      // Check if this was fallback content
      if (data.note) {
        toastMessage = `${data.note}. You can edit this template.`;
        toastVariant = 'default'; // Keep it friendly even for fallbacks
      }
      
      toast({
        title: 'Post Generated',
        description: toastMessage,
        variant: toastVariant,
      });
      
      // Populate the form with the generated content
      setFormData({
        ...formData,
        title: data.data.title || formData.title,
        content: data.data.content || formData.content,
        slug: data.data.slug || formData.slug,
        imageUrls: data.data.imageUrls || formData.imageUrls,
        tags: data.data.tags || formData.tags,
        autoGenerated: true
      });
    },
    onError: (error: Error) => {
      // This should rarely be triggered now since we handle most errors in mutationFn
      console.error("Unhandled error in generatePostMutation:", error);
      
      // Create a fallback anyway
      const keyword = formData.keyword || "relationship advice";
      
      // Even when errors occur, generate a fallback post
      const fallbackData = {
        title: `${keyword}: Essential Guide`,
        slug: `${keyword.toLowerCase().replace(/[^a-z0-9]+/g, '-')}-essential-guide`,
        content: `<h2>Starting Your ${keyword} Journey</h2><p>This article will guide you through the essentials of ${keyword} and how to incorporate this understanding into your relationship.</p>`,
        imageUrls: [],
        tags: ["relationships", keyword.toLowerCase()],
        autoGenerated: true
      };
      
      toast({
        title: 'Using Template Content',
        description: 'AI generation had issues, but we created a template for you to edit.',
        variant: 'default',
      });
      
      // Populate the form with fallback content
      setFormData({
        ...formData,
        ...fallbackData
      });
    }
  });
  
  // Handle image upload
  const handleImageUpload = (files: FileList | null) => {
    if (!files || files.length === 0) return;
    
    // Mock implementation - in a real app, upload to server
    const newImageUrls = Array.from(files).map(file => URL.createObjectURL(file));
    
    setFormData({
      ...formData,
      imageUrls: [...(formData.imageUrls || []), ...newImageUrls]
    });
    
    toast({
      title: 'Images Added',
      description: `${files.length} image(s) added to the post.`,
      variant: 'default',
    });
  };
  
  // Fetch images from Pexels API
  const [pexelsSearchTerm, setPexelsSearchTerm] = useState('');
  const [pexelsDialogOpen, setPexelsDialogOpen] = useState(false);
  const [pexelsImages, setPexelsImages] = useState<Array<{ id: string, src: { medium: string, original: string }; photographer: string; }>>([]);
  const [isPexelsLoading, setIsPexelsLoading] = useState(false);
  
  const fetchPexelsImages = async (searchTerm: string) => {
    if (!searchTerm.trim()) {
      toast({
        title: 'Search Term Required',
        description: 'Please enter a keyword to search for images.',
        variant: 'destructive',
      });
      return;
    }
    
    setIsPexelsLoading(true);
    
    try {
      const response = await fetch(`/api/admin/pexels?query=${encodeURIComponent(searchTerm)}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error ${response.status}`);
      }
      
      const data = await response.json();
      setPexelsImages(data.data.photos || []);
    } catch (error) {
      toast({
        title: 'Error Fetching Images',
        description: error instanceof Error ? error.message : 'Failed to fetch images',
        variant: 'destructive',
      });
    } finally {
      setIsPexelsLoading(false);
    }
  };
  
  const handleAddPexelsImage = (imageUrl: string) => {
    setFormData({
      ...formData,
      imageUrls: [...(formData.imageUrls || []), imageUrl]
    });
    
    toast({
      title: 'Image Added',
      description: 'The selected image has been added to your post.',
      variant: 'default',
    });
    
    setPexelsDialogOpen(false);
  };
  
  // Handle tag addition
  const handleAddTag = () => {
    if (!tagInput.trim()) return;
    
    const newTag = tagInput.trim();
    if (!formData.tags?.includes(newTag)) {
      setFormData({
        ...formData,
        tags: [...(formData.tags || []), newTag]
      });
    }
    
    setTagInput('');
  };
  
  // Handle tag removal
  const handleRemoveTag = (tag: string) => {
    setFormData({
      ...formData,
      tags: formData.tags?.filter(t => t !== tag)
    });
  };
  
  // Handle generating slug from title
  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const title = e.target.value;
    const slug = title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '');
    
    setFormData({
      ...formData,
      title,
      slug
    });
  };
  
  // Reset form data
  const resetFormData = () => {
    setFormData({
      title: '',
      slug: '',
      content: '',
      keyword: '',
      category: 'Relationships',
      tags: [],
      imageUrls: [],
      autoGenerated: false
    });
  };
  
  // Set up form data for editing
  const handleEditPost = (post: BlogPost) => {
    setSelectedPostId(post.id);
    setFormData({
      title: post.title,
      slug: post.slug,
      content: post.content,
      keyword: post.keyword,
      category: post.category,
      tags: post.tags || [],
      imageUrls: post.imageUrls || [],
      autoGenerated: post.autoGenerated
    });
    setIsEditDialogOpen(true);
  };
  
  // Handle post view
  const handleViewPost = (post: BlogPost) => {
    setSelectedPostId(post.id);
    setFormData(post);
    setIsViewDialogOpen(true);
  };
  
  // Handle post delete
  const handleDeletePost = (postId: number) => {
    setSelectedPostId(postId);
    setIsDeleteDialogOpen(true);
  };
  
  // Handle sort toggle
  const handleSort = (field: 'date' | 'title' | 'keyword') => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };
  
  // Loading state
  if (postsLoading) {
    return (
      <div className="flex flex-col items-center justify-center h-screen">
        <Loader2 className="h-10 w-10 text-primary animate-spin mb-4" />
        <p className="text-muted-foreground">Loading blog posts...</p>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto py-8 px-4">
      <div className="flex items-center mb-6">
        <Link href="/admin">
          <Button variant="outline" size="sm" className="mr-4">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Dashboard
          </Button>
        </Link>
        <div>
          <h1 className="text-3xl font-bold">Blog Post Management</h1>
          <p className="text-muted-foreground">Create, edit, and manage all blog content</p>
        </div>
      </div>
      
      <div className="mb-6 flex flex-col md:flex-row gap-4 justify-between items-start md:items-center">
        <div className="flex flex-col sm:flex-row gap-4">
          <div className="relative w-full sm:w-80">
            <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search by title or keyword..."
              className="pl-8"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
          
          <Select
            value={filterType}
            onValueChange={(value: 'all' | 'auto' | 'manual') => setFilterType(value)}
          >
            <SelectTrigger className="w-full sm:w-40">
              <SelectValue placeholder="Filter by type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Posts</SelectItem>
              <SelectItem value="auto">Auto-Generated</SelectItem>
              <SelectItem value="manual">Manually Created</SelectItem>
            </SelectContent>
          </Select>
        </div>
        
        <div className="flex gap-4 w-full sm:w-auto">
          <Dialog open={isKeywordDialogOpen} onOpenChange={setIsKeywordDialogOpen}>
            <DialogTrigger asChild>
              <Button variant="outline">
                <Tag className="h-4 w-4 mr-2" />
                Manage Keywords
              </Button>
            </DialogTrigger>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Keyword Management</DialogTitle>
                <DialogDescription>
                  Add and manage keywords for blog post generation
                </DialogDescription>
              </DialogHeader>
              
              <div className="space-y-4 py-4">
                <div className="flex gap-2 items-end">
                  <div className="flex-1 space-y-1">
                    <Label htmlFor="keyword">New Keyword</Label>
                    <Input
                      id="keyword"
                      placeholder="Enter keyword..."
                      value={newKeyword}
                      onChange={(e) => setNewKeyword(e.target.value)}
                    />
                  </div>
                  <div className="w-1/3 space-y-1">
                    <Label htmlFor="category">Category</Label>
                    <Select 
                      value={newKeywordCategory} 
                      onValueChange={setNewKeywordCategory}
                    >
                      <SelectTrigger id="category">
                        <SelectValue placeholder="Category" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="relationships">Relationships</SelectItem>
                        <SelectItem value="communication">Communication</SelectItem>
                        <SelectItem value="attraction">Attraction</SelectItem>
                        <SelectItem value="dating">Dating</SelectItem>
                        <SelectItem value="marriage">Marriage</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <Button 
                    onClick={() => addKeywordMutation.mutate({ 
                      keyword: newKeyword, 
                      category: newKeywordCategory 
                    })} 
                    disabled={!newKeyword.trim() || addKeywordMutation.isPending}
                  >
                    {addKeywordMutation.isPending ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      <Plus className="h-4 w-4" />
                    )}
                    Add
                  </Button>
                </div>
                
                <div className="border rounded-md p-4 h-60 overflow-y-auto">
                  <h3 className="font-medium mb-2">Available Keywords</h3>
                  
                  {keywordsLoading ? (
                    <div className="flex justify-center items-center h-40">
                      <Loader2 className="h-6 w-6 text-primary animate-spin" />
                    </div>
                  ) : keywords.length === 0 ? (
                    <div className="text-center text-muted-foreground py-10">
                      No keywords available. Add some keywords to get started.
                    </div>
                  ) : (
                    <div className="grid grid-cols-2 gap-2">
                      {keywords.map((keyword) => (
                        <div key={keyword.id} className="flex items-center">
                          <Badge variant={keyword.used ? "secondary" : "outline"} className="mr-2">
                            {keyword.category || 'general'}
                          </Badge>
                          <span className={keyword.used ? "text-muted-foreground" : ""}>
                            {keyword.keyword}
                          </span>
                          {keyword.used && (
                            <CheckCircle2 className="h-3 w-3 ml-1 text-green-500" />
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
              
              <DialogFooter>
                <Button variant="outline" onClick={() => setIsKeywordDialogOpen(false)}>
                  Close
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
          
          <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
            <DialogTrigger asChild>
              <Button onClick={resetFormData}>
                <Plus className="h-4 w-4 mr-2" />
                New Blog Post
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>Create New Blog Post</DialogTitle>
                <DialogDescription>
                  Create a new blog post either manually or with AI assistance
                </DialogDescription>
              </DialogHeader>
              
              <div className="space-y-4 py-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="title">Title</Label>
                    <Input 
                      id="title" 
                      value={formData.title} 
                      onChange={handleTitleChange} 
                      placeholder="Enter post title" 
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="slug">URL Slug</Label>
                    <Input 
                      id="slug" 
                      value={formData.slug} 
                      onChange={(e) => setFormData({...formData, slug: e.target.value})} 
                      placeholder="url-friendly-slug" 
                    />
                  </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="keyword">Keyword</Label>
                    <Select 
                      value={formData.keyword} 
                      onValueChange={(value) => setFormData({...formData, keyword: value})}
                    >
                      <SelectTrigger id="keyword">
                        <SelectValue placeholder="Select a keyword" />
                      </SelectTrigger>
                      <SelectContent>
                        {keywords.map((keyword) => (
                          <SelectItem key={keyword.id} value={keyword.keyword}>
                            {keyword.keyword}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="category">Category</Label>
                    <Select 
                      value={formData.category} 
                      onValueChange={(value) => setFormData({...formData, category: value})}
                    >
                      <SelectTrigger id="category">
                        <SelectValue placeholder="Select a category" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="Relationships">Relationships</SelectItem>
                        <SelectItem value="Communication">Communication</SelectItem>
                        <SelectItem value="Attraction">Attraction</SelectItem>
                        <SelectItem value="Dating">Dating</SelectItem>
                        <SelectItem value="Marriage">Marriage</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                
                <div className="flex flex-col space-y-2">
                  <Label>Tags</Label>
                  <div className="flex flex-wrap gap-2 mb-2">
                    {formData.tags?.map((tag) => (
                      <Badge key={tag} variant="secondary" className="gap-1">
                        {tag}
                        <button 
                          onClick={() => handleRemoveTag(tag)}
                          className="ml-1 h-4 w-4 rounded-full bg-primary/20 inline-flex items-center justify-center hover:bg-primary/50"
                        >
                          <XCircle className="h-3 w-3" />
                        </button>
                      </Badge>
                    ))}
                  </div>
                  <div className="flex gap-2">
                    <Input
                      placeholder="Add a tag..."
                      value={tagInput}
                      onChange={(e) => setTagInput(e.target.value)}
                      onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}
                    />
                    <Button type="button" onClick={handleAddTag} variant="outline">Add</Button>
                  </div>
                </div>
                
                <div className="flex flex-col space-y-2">
                  <Label>Images</Label>
                  <div className="flex flex-wrap gap-2 mb-2">
                    {formData.imageUrls?.map((url, index) => (
                      <div key={index} className="relative group">
                        <img src={url} alt={`Post image ${index}`} className="h-20 w-20 object-cover rounded-md" />
                        <button 
                          onClick={() => setFormData({
                            ...formData,
                            imageUrls: formData.imageUrls?.filter((_, i) => i !== index)
                          })}
                          className="absolute top-1 right-1 h-6 w-6 rounded-full bg-black/60 text-white flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                        >
                          <XCircle className="h-4 w-4" />
                        </button>
                      </div>
                    ))}
                    {formData.imageUrls?.length === 0 && (
                      <div className="border border-dashed rounded-md flex items-center justify-center w-full h-32 text-muted-foreground">
                        No images added yet
                      </div>
                    )}
                  </div>
                  <div className="flex items-center gap-4">
                    <Label htmlFor="image-upload" className="cursor-pointer">
                      <div className="flex items-center gap-2 p-2 border rounded-md hover:bg-accent">
                        <UploadCloud className="h-5 w-5 text-muted-foreground" />
                        <span>Upload Images</span>
                      </div>
                      <Input 
                        id="image-upload" 
                        type="file" 
                        accept="image/*" 
                        className="hidden" 
                        multiple 
                        onChange={(e) => handleImageUpload(e.target.files)}
                      />
                    </Label>
                    <Button variant="outline" type="button" onClick={() => setPexelsDialogOpen(true)}>
                      <ImageIcon className="h-4 w-4 mr-2" />
                      Add from Pexels
                    </Button>
                  </div>
                </div>
                
                <div className="space-y-2">
                  <div className="flex justify-between items-center">
                    <Label htmlFor="content">Content</Label>
                    <div className="flex space-x-2">
                      <Button 
                        variant="outline" 
                        size="sm" 
                        onClick={() => generatePostMutation.mutate({ keyword: formData.keyword || '' })}
                        disabled={!formData.keyword || generatePostMutation.isPending}
                      >
                        {generatePostMutation.isPending ? (
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        ) : (
                          <FileText className="h-4 w-4 mr-2" />
                        )}
                        Generate with AI
                      </Button>
                      <Button 
                        variant="secondary" 
                        size="sm" 
                        className="bg-green-100 hover:bg-green-200 text-green-900"
                        onClick={async () => {
                          if (!formData.keyword) return;
                          
                          toast({
                            title: 'AI Engine Test',
                            description: 'Testing AI engines for blog generation...',
                          });
                          
                          try {
                            // Test both engines
                            const response = await fetch('/api/admin/blog/generate', {
                              method: 'POST',
                              headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                              },
                              body: JSON.stringify({ keyword: formData.keyword, test: true })
                            });
                            
                            const data = await response.json();
                            
                            toast({
                              title: 'AI Test Results',
                              description: data.note || 'Test completed successfully.',
                            });
                          } catch (error) {
                            toast({
                              title: 'Test Failed',
                              description: 'Could not test AI engines. See console for details.',
                              variant: 'destructive',
                            });
                            console.error(error);
                          }
                        }}
                        disabled={!formData.keyword || generatePostMutation.isPending}
                      >
                        <FileText className="h-4 w-4 mr-2" />
                        Test AI Engines
                      </Button>
                    </div>
                  </div>
                  <RichTextEditor 
                    value={formData.content || ''} 
                    onChange={(value) => setFormData({...formData, content: value})} 
                    placeholder="Write your blog post content here..."
                    minHeight="400px"
                  />
                </div>
              </div>
              
              <DialogFooter>
                <Button variant="outline" onClick={() => setIsCreateDialogOpen(false)}>Cancel</Button>
                <Button 
                  onClick={() => createPostMutation.mutate(formData)}
                  disabled={!formData.title || !formData.content || !formData.keyword || createPostMutation.isPending}
                >
                  {createPostMutation.isPending ? (
                    <div className="flex items-center gap-2">
                      <Loader2 className="h-4 w-4 animate-spin" />
                      <span>Creating...</span>
                    </div>
                  ) : 'Publish Post'}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>
      </div>
      
      <Card>
        <CardHeader>
          <CardTitle>Blog Posts</CardTitle>
          <CardDescription>
            {filteredPosts.length} post{filteredPosts.length !== 1 ? 's' : ''} found
          </CardDescription>
        </CardHeader>
        <CardContent>
          {blogPosts.length === 0 ? (
            <div className="text-center py-12">
              <FileText className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
              <h3 className="text-lg font-medium mb-2">No blog posts yet</h3>
              <p className="text-muted-foreground mb-4">Create your first blog post to get started</p>
              <Button onClick={() => setIsCreateDialogOpen(true)}>Create Your First Post</Button>
            </div>
          ) : filteredPosts.length === 0 ? (
            <div className="text-center py-12">
              <Search className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
              <h3 className="text-lg font-medium mb-2">No matching posts found</h3>
              <p className="text-muted-foreground mb-4">Try changing your search or filter settings</p>
              <Button variant="outline" onClick={() => { setSearchTerm(''); setFilterType('all'); }}>
                Clear Filters
              </Button>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>ID</TableHead>
                    <TableHead>
                      <button 
                        className="flex items-center gap-1 hover:text-primary" 
                        onClick={() => handleSort('title')}
                      >
                        Title
                        {sortField === 'title' ? (
                          sortDirection === 'asc' ? <SortAsc className="h-4 w-4" /> : <SortDesc className="h-4 w-4" />
                        ) : <ArrowUpDown className="h-4 w-4" />}
                      </button>
                    </TableHead>
                    <TableHead>
                      <button 
                        className="flex items-center gap-1 hover:text-primary" 
                        onClick={() => handleSort('keyword')}
                      >
                        Keyword
                        {sortField === 'keyword' ? (
                          sortDirection === 'asc' ? <SortAsc className="h-4 w-4" /> : <SortDesc className="h-4 w-4" />
                        ) : <ArrowUpDown className="h-4 w-4" />}
                      </button>
                    </TableHead>
                    <TableHead>
                      <button 
                        className="flex items-center gap-1 hover:text-primary" 
                        onClick={() => handleSort('date')}
                      >
                        Published
                        {sortField === 'date' ? (
                          sortDirection === 'asc' ? <SortAsc className="h-4 w-4" /> : <SortDesc className="h-4 w-4" />
                        ) : <ArrowUpDown className="h-4 w-4" />}
                      </button>
                    </TableHead>
                    <TableHead>Status</TableHead>
                    <TableHead>Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredPosts.map((post) => (
                    <TableRow key={post.id}>
                      <TableCell className="font-medium">{post.id}</TableCell>
                      <TableCell>{post.title}</TableCell>
                      <TableCell>
                        <Badge variant="outline">{post.keyword}</Badge>
                      </TableCell>
                      <TableCell>{new Date(post.publishedAt).toLocaleDateString()}</TableCell>
                      <TableCell>
                        <Badge variant={post.autoGenerated ? "secondary" : "default"}>
                          {post.autoGenerated ? 'Auto-generated' : 'Manual'}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <Button variant="ghost" size="icon" onClick={() => handleViewPost(post)}>
                            <Eye className="h-4 w-4" />
                          </Button>
                          <Button variant="ghost" size="icon" onClick={() => handleEditPost(post)}>
                            <Pencil className="h-4 w-4" />
                          </Button>
                          <Button variant="ghost" size="icon" onClick={() => handleDeletePost(post.id)}>
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
          )}
        </CardContent>
      </Card>
      
      {/* Edit Post Dialog */}
      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
        <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Edit Blog Post</DialogTitle>
            <DialogDescription>
              Make changes to the blog post
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4 py-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="edit-title">Title</Label>
                <Input 
                  id="edit-title" 
                  value={formData.title} 
                  onChange={handleTitleChange} 
                  placeholder="Enter post title" 
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="edit-slug">URL Slug</Label>
                <Input 
                  id="edit-slug" 
                  value={formData.slug} 
                  onChange={(e) => setFormData({...formData, slug: e.target.value})} 
                  placeholder="url-friendly-slug" 
                />
              </div>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="edit-keyword">Keyword</Label>
                <Select 
                  value={formData.keyword} 
                  onValueChange={(value) => setFormData({...formData, keyword: value})}
                >
                  <SelectTrigger id="edit-keyword">
                    <SelectValue placeholder="Select a keyword" />
                  </SelectTrigger>
                  <SelectContent>
                    {keywords.map((keyword) => (
                      <SelectItem key={keyword.id} value={keyword.keyword}>
                        {keyword.keyword}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="edit-category">Category</Label>
                <Select 
                  value={formData.category} 
                  onValueChange={(value) => setFormData({...formData, category: value})}
                >
                  <SelectTrigger id="edit-category">
                    <SelectValue placeholder="Select a category" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="Relationships">Relationships</SelectItem>
                    <SelectItem value="Communication">Communication</SelectItem>
                    <SelectItem value="Attraction">Attraction</SelectItem>
                    <SelectItem value="Dating">Dating</SelectItem>
                    <SelectItem value="Marriage">Marriage</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
            
            <div className="flex flex-col space-y-2">
              <Label>Tags</Label>
              <div className="flex flex-wrap gap-2 mb-2">
                {formData.tags?.map((tag) => (
                  <Badge key={tag} variant="secondary" className="gap-1">
                    {tag}
                    <button 
                      onClick={() => handleRemoveTag(tag)}
                      className="ml-1 h-4 w-4 rounded-full bg-primary/20 inline-flex items-center justify-center hover:bg-primary/50"
                    >
                      <XCircle className="h-3 w-3" />
                    </button>
                  </Badge>
                ))}
              </div>
              <div className="flex gap-2">
                <Input
                  placeholder="Add a tag..."
                  value={tagInput}
                  onChange={(e) => setTagInput(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}
                />
                <Button type="button" onClick={handleAddTag} variant="outline">Add</Button>
              </div>
            </div>
            
            <div className="flex flex-col space-y-2">
              <Label>Images</Label>
              <div className="flex flex-wrap gap-2 mb-2">
                {formData.imageUrls?.map((url, index) => (
                  <div key={index} className="relative group">
                    <img src={url} alt={`Post image ${index}`} className="h-20 w-20 object-cover rounded-md" />
                    <button 
                      onClick={() => setFormData({
                        ...formData,
                        imageUrls: formData.imageUrls?.filter((_, i) => i !== index)
                      })}
                      className="absolute top-1 right-1 h-6 w-6 rounded-full bg-black/60 text-white flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                      <XCircle className="h-4 w-4" />
                    </button>
                  </div>
                ))}
              </div>
              <div className="flex items-center gap-4">
                <Label htmlFor="edit-image-upload" className="cursor-pointer">
                  <div className="flex items-center gap-2 p-2 border rounded-md hover:bg-accent">
                    <UploadCloud className="h-5 w-5 text-muted-foreground" />
                    <span>Upload Images</span>
                  </div>
                  <Input 
                    id="edit-image-upload" 
                    type="file" 
                    accept="image/*" 
                    className="hidden" 
                    multiple 
                    onChange={(e) => handleImageUpload(e.target.files)}
                  />
                </Label>
                <Button variant="outline" type="button" onClick={() => setPexelsDialogOpen(true)}>
                  <ImageIcon className="h-4 w-4 mr-2" />
                  Add from Pexels
                </Button>
              </div>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="edit-content">Content</Label>
              <RichTextEditor 
                value={formData.content || ''} 
                onChange={(value) => setFormData({...formData, content: value})} 
                placeholder="Write your blog post content here..."
                minHeight="400px"
              />
            </div>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsEditDialogOpen(false)}>Cancel</Button>
            <Button 
              onClick={() => updatePostMutation.mutate(formData)}
              disabled={!formData.title || !formData.content || !formData.keyword || updatePostMutation.isPending}
            >
              {updatePostMutation.isPending ? (
                <div className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <span>Updating...</span>
                </div>
              ) : (
                <>
                  <Save className="h-4 w-4 mr-2" />
                  Update Post
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {/* View Post Dialog */}
      <Dialog open={isViewDialogOpen} onOpenChange={setIsViewDialogOpen}>
        <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>{formData.title}</DialogTitle>
            <DialogDescription>
              Published on {formData.publishedAt && new Date(formData.publishedAt).toLocaleDateString()}
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4 py-4">
            <div className="flex flex-wrap gap-2">
              <Badge variant="outline">{formData.keyword}</Badge>
              <Badge variant="secondary">{formData.category}</Badge>
              {formData.tags?.map((tag) => (
                <Badge key={tag} variant="default">{tag}</Badge>
              ))}
            </div>
            
            {formData.imageUrls && formData.imageUrls.length > 0 && (
              <div className="flex overflow-x-auto gap-2 pb-2">
                {formData.imageUrls.map((url, index) => (
                  <img 
                    key={index} 
                    src={url} 
                    alt={`Post image ${index}`} 
                    className="h-40 w-auto object-cover rounded-md"
                  />
                ))}
              </div>
            )}
            
            <div className="prose prose-stone dark:prose-invert max-w-none">
              <div dangerouslySetInnerHTML={{ __html: formData.content || '' }} />
            </div>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsViewDialogOpen(false)}>Close</Button>
            <Button variant="default" onClick={() => {
              setIsViewDialogOpen(false);
              handleEditPost(formData as BlogPost);
            }}>
              <Pencil className="h-4 w-4 mr-2" />
              Edit
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {/* Delete Post Confirmation */}
      <AlertDialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the blog post 
              and remove it from the website.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={() => selectedPostId && deletePostMutation.mutate(selectedPostId)}
              className="bg-red-500 hover:bg-red-600"
            >
              {deletePostMutation.isPending ? (
                <div className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <span>Deleting...</span>
                </div>
              ) : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
      
      {/* Pexels Image Search Dialog */}
      <Dialog open={pexelsDialogOpen} onOpenChange={setPexelsDialogOpen}>
        <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Search Pexels Images</DialogTitle>
            <DialogDescription>
              Search and select images for your blog post
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4 py-4">
            <div className="flex gap-2">
              <Input
                placeholder="Search for images (e.g., 'couple', 'romance', 'dating')..."
                value={pexelsSearchTerm}
                onChange={(e) => setPexelsSearchTerm(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && fetchPexelsImages(pexelsSearchTerm)}
                className="flex-1"
              />
              <Button 
                onClick={() => fetchPexelsImages(pexelsSearchTerm)}
                disabled={isPexelsLoading || !pexelsSearchTerm.trim()}
              >
                {isPexelsLoading ? (
                  <Loader2 className="h-4 w-4 animate-spin mr-2" />
                ) : (
                  <Search className="h-4 w-4 mr-2" />
                )}
                Search
              </Button>
            </div>
            
            <div className="border rounded-md p-4 min-h-[300px]">
              {isPexelsLoading ? (
                <div className="flex flex-col items-center justify-center h-64">
                  <Loader2 className="h-10 w-10 text-primary animate-spin mb-4" />
                  <p className="text-muted-foreground">Searching for images...</p>
                </div>
              ) : pexelsImages.length === 0 ? (
                <div className="flex flex-col items-center justify-center h-64 text-center">
                  <ImageIcon className="h-12 w-12 text-muted-foreground mb-4" />
                  <p className="text-muted-foreground mb-2">No images found</p>
                  <p className="text-xs text-muted-foreground max-w-md">
                    Try searching for different terms like "couple", "relationship", "romance", etc.
                  </p>
                </div>
              ) : (
                <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                  {pexelsImages.map((image) => (
                    <div 
                      key={image.id} 
                      className="relative group cursor-pointer rounded-md overflow-hidden"
                      onClick={() => handleAddPexelsImage(image.src.original)}
                    >
                      <img 
                        src={image.src.medium} 
                        alt={`Photo by ${image.photographer}`} 
                        className="w-full h-48 object-cover"
                      />
                      <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center flex-col text-white p-2 text-center">
                        <Plus className="h-8 w-8 mb-2" />
                        <p className="text-xs">Click to add this image</p>
                        <p className="text-[10px] mt-1">Photo by {image.photographer}</p>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setPexelsDialogOpen(false)}>
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default BlogManagement;